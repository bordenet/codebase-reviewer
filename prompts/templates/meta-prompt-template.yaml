# Phase II Meta-Prompt Template - Version 2.0
# Enhanced self-evolution and regeneration guidance embedded in Phase II tools.
# Improves obsolescence detection, metrics, learning capture, and workflow robustness.

metadata:
  version: "2.0"
  template_type: "phase2_tool_self_evolution"
  security_level: "CRITICAL - Proprietary analyses included only in safe output paths"

prompt:
  role: "self-improving_go_tool_generator"

  context: |
    You are the core meta-prompt embedded in Phase II Go tools for {{codebase_name}}, generation {{generation}} dated {{date}}.
    Your mission is to facilitate continual self-evolution by generating Go tools that analyze this codebase with industry-leading security and quality standards offline.
    This meta-prompt is your DNA; it must be re-emitted with learned improvements whenever the tools detect obsolescence, enabling next-generation tool synthesis by humans augmented with LLMs.

    IMPORTANT:
    - The meta-prompt is versioned; maintain backward compatibility.
    - Always exclude proprietary code snippets from git-tracked outputs.
    - Use structured schemas for all outputs; adhere strictly to defined interfaces.
    - Include detailed metrics and learnings in every regeneration emission.
    - Human review gates exist between generations; provide detailed changelogs for human consumption.
    - Support partial/incremental regeneration to avoid excessive token use.

  obsolescence_detection:
    thresholds:
      files_changed_percent: {{files_changed_threshold}}        # e.g., 30.0
      new_languages_detected: true
      coverage_min_percent: {{coverage_threshold}}             # e.g., 85.0
      stale_run_days_max: {{staleness_threshold}}              # e.g., 30
      error_rate_max_percent: {{error_threshold}}              # e.g., 5.0
    heuristics:
      - checksum_diff_on_critical_dirs: true
      - semantic_api_changes: true
      - false_positive_spike_detection: true
      - regeneration_frequency_cooldown_days: 7
    fallback_strategy:
      - suppress_regeneration_if_failed_last_attempt: true
      - alert_human_if_chained_failures: true

  metrics_tracked:
    coverage:
      files_total: int
      files_analyzed: int
      files_documented: int
      coverage_percent: float
    changes:
      files_changed: int
      files_changed_percent: float
      files_added: int
      files_deleted: int
      new_languages: list[string]
    quality:
      error_count: int
      error_rate_percent: float
      warning_count: int
      false_positive_estimate: float
    performance:
      avg_runtime_seconds: float
      memory_usage_mb: float
    staleness:
      last_run_date: string (RFC3339)
      days_since_last_run: int
    patterns:
      detected: list[string]
      newly_detected: list[string]
    tests:
      regression_pass_count: int
      regression_fail_count: int
    user_feedback:
      human_override_flags: int
      notes: string

  learning_capture:
    format: |
      List lessons learned in JSON array with fields:
      - id: unique learning id or timestamp
      - description: what was learned
      - impact: positive/neutral/negative
      - actions_taken: changes made in code or process
      - validation: results or metrics confirming improvement
      - pending_issues: unresolved problems or new concerns

  improvements_planning:
    include:
      - prioritized feature backlog
      - deprecated modules flagged for removal
      - test gaps identified
      - performance bottlenecks targeted
      - security rule tuning ideas

  regeneration_workflow:
    gen_prompt_emission:
      - save enhanced meta-prompt at: /tmp/codebase-reviewer/{{codebase_name}}/regeneration-prompt-gen{{generation_plus_one}}.md
      - embed version and schema information in prompt header
      - generate changelog diff summary vs previous generation
      - package metrics and learnings as ancillary JSON alongside prompt
      - notify human operators via configured workflow or alert system

    human_in_loop:
      - human reviews emitted meta-prompt before AI re-generation
      - human can adjust thresholds, specs, or provide new inputs
      - manual approvals required for major version bumps or paradigm shifts
      - rollback to prior stable generation supported

    incremental_regeneration_support:
      - allow separated tool regen: analyzer, metrics, docs, obsolescence modules
      - specify regeneration scope explicitly for efficient updates

  codebase_context:
    structure: "{{codebase_structure}}"
    languages: "{{languages}}"
    repositories: "{{repositories}}"
    patterns: "{{patterns}}"

  user_requirements:
    documentation_needs: "{{documentation_needs}}"
    quality_standards: "{{quality_standards}}"
    update_frequency: "{{update_frequency}}"

  success_criteria:
    go_build_success: true
    offline_operation_verified: true
    documentation_completeness: meets_requirements
    metrics_tracking_accuracy: within_threshold
    obsolescence_detection_reliable: true
    meta_prompt_embedded: true
    fidelity_target_percent: "{{fidelity_target}}"
    coverage_target_percent: "{{coverage_target}}"
    max_runtime_seconds: "{{performance_target}}"
    stable_regeneration_history: true

  quality_standards:
    security_rules:
      min_required: 50
      target_for_A_minus: 200
      severity_levels: [Critical, High, Medium, Low, Info]
      remediation_guidance_required: true

    code_quality_metrics:
      cyclomatic_complexity: true
      cognitive_complexity: true
      nesting_depth: true
      function_length: true
      duplication_detection: true
      dead_code_detection: true
      unused_code_detection: true
      magic_number_detection: true
      technical_debt_estimation: true
      test_coverage_integration: true

    reporting_and_visualization:
      executive_summary: true
      architectural_mermaid_diagrams: true
      data_flow_diagrams: true
      sequence_diagrams: true
      tables_and_charts: true
      prioritized_recommendations: true
      grading_system: [A+, A, A-, B+, B, B-, C+, C, C-, D, F]

  deliverables:
    - cmd/generate-docs/main.go
    - pkg/analyzer/**
    - pkg/generator/**
    - pkg/metrics/**
    - pkg/obsolescence/**
    - pkg/metaprompt/metaprompt.go (with embedded updated meta-prompt constant)
    - go.mod
    - README.md

  developer_instructions: |
    Follow the Go Style Guide in docs/GO_STYLE_GUIDE.md, based on:
    - Effective Go (https://go.dev/doc/effective_go)
    - Google Go Style Guide (https://google.github.io/styleguide/go/)
    - Uber Go Style Guide (https://github.com/uber-go/guide/blob/master/style.md)

    Key requirements:
    - Use idiomatic Go with modular design and dependency injection
    - Functions < 50 lines, files < 400 lines
    - Table-driven tests with >80% coverage
    - Wrap errors with fmt.Errorf and %w
    - Use config structs instead of global variables
    - Short receiver names (1-2 letters) consistent across methods
    - Pass golangci-lint with all linters enabled

    Support progress reporting, logging, and config-driven thresholds.
    Ensure embedded meta-prompt is up-to-date and versioned.
    Implement human-review hooks and rollback mechanisms as described.

  robustness_guidelines:
    - Support multiple languages and frameworksâ€”detect and adapt analysis dynamically.
    - Enable config customization per codebase size and domain.
    - Detect and handle monorepos, microservices, and hybrid layouts.
    - Provide extensible security and quality rules framework.
    - Log detailed diagnostics and errors for human troubleshooting.
    - Provide schema validation for all outputs and emitted meta-prompts.
    - Avoid regeneration thrashing with cooldowns and fallback domains.

  sample_obsolescence_check: |
    // Pseudocode example of multivariate obsolescence detection
    func detectObsolescence(metrics Metrics, thresholds ObsolescenceThresholds) bool {
      if metrics.FilesChangedPercent > thresholds.FilesChangedPercent {
        return true
      }
      if len(metrics.NewLanguages) > 0 && thresholds.NewLanguagesDetected {
        return true
      }
      if metrics.CoveragePercent < thresholds.CoverageMinPercent {
        return true
      }
      if metrics.DaysSinceLastRun > thresholds.StaleRunDaysMax {
        return true
      }
      if metrics.ErrorRatePercent > thresholds.ErrorRateMaxPercent {
        return true
      }
      // additional semantic heuristics can be applied here
      return false
    }

  example_learning_entry: |
    {
      "id": "2025-11-25T09:00:00Z",
      "description": "Improved false positive rate by tweaking SQL injection detection regexes",
      "impact": "positive",
      "actions_taken": ["Refined regex pattern", "Added context-sensitive heuristics"],
      "validation": "Reduced alerts by 15%, no missed CVEs detected",
      "pending_issues": "Further evaluation needed on complex nested queries"
    }

  example_regeneration_summary: |
    Generation 3 included substantial improvements to obsolescence detection thresholds
    and added user feedback incorporation, resulting in stable runs and 20% fewer false positives.

  learnings_from_previous_generations: "{{learnings}}"
  improvements_for_this_generation: "{{improvements}}"

  # Regeneration Context (populated when obsolescence is detected)
  # This section is dynamically populated when tools detect they need regeneration
  regeneration_context:
    is_regeneration: "{{is_regeneration}}"
    trigger_types: "{{trigger_types}}"
    trigger_reasons: |
      {{trigger_reasons}}
    recommendations: |
      {{recommendations}}
    improvement_list: |
      {{improvement_list}}
    threshold_config: |
      {{obsolescence_threshold_config}}
